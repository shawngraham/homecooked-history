<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semantic Spectrum Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3/dist/universal-sentence-encoder.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .header-controls {
            margin-top: 20px;
        }

        .info-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .info-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            padding: 30px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .spectrum-section {
            background: #f8f9ff;
            border-radius: 15px;
            padding: 25px;
            border: 2px solid #e1e8ff;
        }

        .spectrum-section h2 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .spectrum-inputs {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .spectrum-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e1e8ff;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
            resize: vertical;
            min-height: 45px;
            font-family: inherit;
        }

        .spectrum-input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .spectrum-arrow {
            font-size: 1.5rem;
            color: #4facfe;
            font-weight: bold;
        }

        .spectrum-visual {
            height: 20px;
            background: linear-gradient(90deg, #ff6b6b 0%, #ffe66d 50%, #4ecdc4 100%);
            border-radius: 10px;
            position: relative;
            margin: 15px 0;
        }

        .spectrum-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .text-section {
            background: #f8f9ff;
            border-radius: 15px;
            padding: 25px;
            border: 2px solid #e1e8ff;
        }

        .text-input {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            border: 2px solid #e1e8ff;
            border-radius: 10px;
            font-size: 1rem;
            font-family: inherit;
            resize: vertical;
            background: white;
            transition: all 0.3s ease;
        }

        .text-input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .analyze-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            width: 100%;
        }

        .analyze-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(79, 172, 254, 0.3);
        }

        .analyze-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .results {
            grid-column: 1 / -1;
            margin-top: 30px;
        }

        .results-section {
            background: #f8f9ff;
            border-radius: 15px;
            padding: 25px;
            border: 2px solid #e1e8ff;
        }

        .analyzed-text {
            line-height: 1.8;
            font-size: 1.1rem;
        }

        .sentence {
            padding: 8px 12px;
            margin: 2px 0;
            border-radius: 8px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .sentence:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.1rem;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #4facfe;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .legend {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            border: 1px solid #e1e8ff;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .status.info {
            background: #e3f2fd;
            color: #1565c0;
            border: 1px solid #bbdefb;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #ffcdd2;
        }

        .status.success {
            background: #e8f5e8;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: white;
            margin: 5% auto;
            padding: 0;
            border-radius: 20px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal-header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 25px 30px;
            border-radius: 20px 20px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.8rem;
            font-weight: 300;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 50%;
            transition: all 0.3s ease;
            opacity: 0.8;
        }

        .close-btn:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.2);
        }

        .modal-body {
            padding: 30px;
            line-height: 1.6;
            color: #444;
        }

        .modal-body h3 {
            color: #4facfe;
            margin: 25px 0 15px 0;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-body h3:first-child {
            margin-top: 0;
        }

        .modal-body p {
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .modal-body ul {
            margin: 15px 0;
            padding-left: 20px;
        }

        .modal-body li {
            margin-bottom: 8px;
        }

        .example-box {
            background: #f8f9ff;
            border-left: 4px solid #4facfe;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 0 10px 10px 0;
        }

        .example-box strong {
            color: #4facfe;
        }

        .tech-details {
            background: #f0f8ff;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid #e1e8ff;
        }

        .color-demo {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .color-sample {
            width: 30px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 20px;
            }
            
            .spectrum-inputs {
                flex-direction: column;
            }
            
            .spectrum-arrow {
                transform: rotate(90deg);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Semantic Spectrum Analyzer</h1>
            <p>Define a spectrum and analyze text sentiment across that dimension</p>
            <p>Inspired by the work of <a href="https://wattenberger.com/thoughts/yay-embeddings-math">Amelia Wattenberger</a></p>
            <p>By <a href="https://shawngraham.github.io">S.M. Graham</a></p>
            <div class="header-controls">
                <button class="info-btn" id="howItWorksBtn">❓ How This Works</button>
            </div>
        </div>
        
        <div class="main-content">
            <div class="controls">
                <div class="spectrum-section">
                    <h2>🎯 Define Your Spectrum</h2>
                    <div class="spectrum-inputs">
                        <textarea class="spectrum-input" id="leftSpectrum" placeholder="e.g., 'The last camel died at noon' or just 'Pessimistic'" rows="2"></textarea>
                        <span class="spectrum-arrow">→</span>
                        <textarea class="spectrum-input" id="rightSpectrum" placeholder="e.g., 'It was a hobbit-hole, and that means comfort' or just 'Optimistic'" rows="2"></textarea>
                    </div>
                    <div class="spectrum-visual"></div>
                    <div class="spectrum-labels">
                        <span id="leftLabel">Left End</span>
                        <span id="rightLabel">Right End</span>
                    </div>
                </div>
                
                <div class="text-section">
                    <h2>📝 Input Text</h2>
                    <textarea class="text-input" id="inputText" placeholder="Paste your text here. Each sentence will be analyzed and colored according to where it falls on your defined spectrum...

For example: 'I'm really excited about this project! However, there are some concerns about the timeline. Overall, I think we can make it work with proper planning.'"></textarea>
                    <button class="analyze-btn" id="analyzeBtn">Analyze Text</button>
                    <div class="status" id="status" style="display: none;"></div>
                </div>
            </div>
        </div>
        
        <div class="results" id="results" style="display: none;">
            <div class="results-section">
                <h2>📊 Analysis Results</h2>
                <div class="legend" id="legend"></div>
                <div class="analyzed-text" id="analyzedText"></div>
            </div>
        </div>
    </div>

    <!-- How It Works Modal -->
    <div id="howItWorksModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>How This Works</h2>
                <button class="close-btn" id="closeModal">&times;</button>
            </div>
            <div class="modal-body">
                <h3>🧠 The Science Behind It</h3>
                <p>This tool uses advanced artificial intelligence to understand the semantic meaning of text and position it on custom spectrums you define. It's powered by Google's Universal Sentence Encoder, a state-of-the-art neural network.</p>

                <h3>🔧 How It Works</h3>
                <div class="tech-details">
                    <p><strong>1. Spectrum Definition:</strong> You define two opposing concepts (like "formal" vs "casual" or "negative" vs "positive")</p>
                    
                    <p><strong>2. AI Embeddings:</strong> The system converts your spectrum concepts and each sentence into high-dimensional vectors (512 dimensions) that capture semantic meaning</p>
                    
                    <p><strong>3. Similarity Calculation:</strong> Using cosine similarity, it measures how close each sentence is to either end of your spectrum</p>
                    
                    <p><strong>4. Visual Mapping:</strong> Sentences are colored based on their position on the spectrum</p>
                </div>

                <h3>🎨 Color Coding</h3>
                <div class="color-demo">
                    <div class="color-sample" style="background-color: rgba(255, 107, 107, 0.7);"></div>
                    <span>Left spectrum (your first concept)</span>
                </div>
                <div class="color-demo">
                    <div class="color-sample" style="background-color: rgba(255, 230, 109, 0.7);"></div>
                    <span>Neutral/Mixed</span>
                </div>
                <div class="color-demo">
                    <div class="color-sample" style="background-color: rgba(78, 205, 196, 0.7);"></div>
                    <span>Right spectrum (your second concept)</span>
                </div>

                <h3>💡 Example Use Cases</h3>
                <div class="example-box">
                    <p><strong>Sentiment Analysis:</strong> "pessimistic" → "optimistic"</p>
                    <p><strong>Tone Analysis:</strong> "formal" → "casual"</p>
                    <p><strong>Certainty Analysis:</strong> "uncertain" → "confident"</p>
                    <p><strong>Complexity Analysis:</strong> "simple" → "technical"</p>
                    <p><strong>nb</strong>You can use phrases too to signal the ends of the spectrum you're after!</p>
                </div>

                <h3>🎯 Tips for Best Results</h3>
                <ul>
                    <li><strong>Use clear opposites:</strong> Choose concepts that are genuinely opposite to each other</li>
                    <li><strong>Be specific:</strong> Instead of "good" vs "bad", try "disappointing" vs "excellent"</li>
                    <li><strong>Single concepts:</strong> Use single words or short phrases rather than sentences</li>
                    <li><strong>Consistent language:</strong> Keep the same language/style for both spectrum ends</li>
                </ul>

                <h3>⚙️ Technical Details</h3>
                <div class="tech-details">
                    <p><strong>Model:</strong> Universal Sentence Encoder (USE) by Google Research</p>
                    <p><strong>Embedding Dimensions:</strong> 512-dimensional vectors</p>
                    <p><strong>Similarity Metric:</strong> Cosine similarity between sentence and spectrum embeddings</p>
                    <p><strong>Processing:</strong> Client-side AI using TensorFlow.js (your data never leaves your browser)</p>
                </div>

                <h3>🔒 Privacy</h3>
                <p>All analysis happens locally in your browser. Your text and spectrum definitions are never sent to any server - everything runs using AI models downloaded to your device.</p>
            </div>
        </div>
    </div>

    <script>
        let model = null;
        let isLoading = false;
        let modelLoadAttempted = false;

        function showStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
        }

        function hideStatus() {
            document.getElementById('status').style.display = 'none';
        }

        // Initialize the Universal Sentence Encoder model
        async function loadModel() {
            if (model) return model;
            if (modelLoadAttempted) {
                throw new Error('Model loading already failed. Please refresh the page.');
            }
            
            modelLoadAttempted = true;
            console.log('Loading Universal Sentence Encoder...');
            
            try {
                // Set TensorFlow.js backend to webgl for better performance
                await tf.setBackend('webgl');
                
                showStatus('Loading AI model... This may take a minute on first load.', 'info');
                
                // Load the model with error handling
                model = await use.load();
                console.log('Model loaded successfully');
                showStatus('AI model loaded successfully!', 'success');
                setTimeout(hideStatus, 3000);
                return model;
                
            } catch (error) {
                console.error('Error loading model:', error);
                showStatus('Failed to load AI model. Please check your internet connection and refresh the page.', 'error');
                throw error;
            }
        }

        // Compute cosine similarity between two vectors
        function cosineSimilarity(a, b) {
            if (a.length !== b.length) {
                throw new Error('Vectors must have the same length');
            }
            
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            
            for (let i = 0; i < a.length; i++) {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            
            if (normA === 0 || normB === 0) {
                return 0;
            }
            
            return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
        }

        // Split text into sentences with better regex
        function splitIntoSentences(text) {
            // More sophisticated sentence splitting
            const sentences = text
                .replace(/([.!?])\s*(?=[A-Z])/g, '$1|')
                .split('|')
                .map(s => s.trim())
                .filter(s => s.length > 3); // Filter out very short fragments
            
            return sentences.length > 0 ? sentences : [text.trim()];
        }

        // Get color based on spectrum position (-1 to 1)
        function getSpectrumColor(position, alpha = 0.7) {
            // Clamp position to [-1, 1] range
            position = Math.max(-1, Math.min(1, position));
            
            // Normalize position from [-1, 1] to [0, 1]
            const normalized = (position + 1) / 2;
            
            if (normalized < 0.5) {
                // Red to Yellow
                const ratio = normalized * 2;
                const r = 255;
                const g = Math.round(ratio * 255);
                const b = Math.round(ratio * 100);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            } else {
                // Yellow to Green
                const ratio = (normalized - 0.5) * 2;
                const r = Math.round(255 * (1 - ratio));
                const g = 255;
                const b = Math.round(100 + ratio * 155);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
        }

        // Update spectrum labels
        function updateSpectrumLabels() {
            const leftText = document.getElementById('leftSpectrum').value.trim() || 'Left End';
            const rightText = document.getElementById('rightSpectrum').value.trim() || 'Right End';
            document.getElementById('leftLabel').textContent = leftText;
            document.getElementById('rightLabel').textContent = rightText;
        }

        // Main analysis function
        async function analyzeText() {
            const leftSpectrum = document.getElementById('leftSpectrum').value.trim();
            const rightSpectrum = document.getElementById('rightSpectrum').value.trim();
            const inputText = document.getElementById('inputText').value.trim();

            if (!leftSpectrum || !rightSpectrum || !inputText) {
                showStatus('Please fill in both spectrum ends and input text.', 'error');
                return;
            }

            if (isLoading) return;
            isLoading = true;

            const analyzeBtn = document.getElementById('analyzeBtn');
            const results = document.getElementById('results');
            
            analyzeBtn.textContent = 'Analyzing...';
            analyzeBtn.disabled = true;

            try {
                // Load model if not already loaded
                if (!model) {
                    await loadModel();
                }
                
                showStatus('Processing text and generating embeddings...', 'info');

                // Split text into sentences
                const sentences = splitIntoSentences(inputText);
                
                if (sentences.length === 0) {
                    throw new Error('No valid sentences found in the text.');
                }

                console.log(`Processing ${sentences.length} sentences...`);

                // Create embeddings for spectrum ends and sentences
                const allTexts = [leftSpectrum, rightSpectrum, ...sentences];
                
                showStatus(`Generating embeddings for ${allTexts.length} text segments...`, 'info');
                
                const embeddings = await model.embed(allTexts);
                const embeddingValues = await embeddings.array();

                // Clean up TensorFlow tensors
                embeddings.dispose();

                const leftEmbedding = embeddingValues[0];
                const rightEmbedding = embeddingValues[1];
                const sentenceEmbeddings = embeddingValues.slice(2);

                showStatus('Calculating semantic similarities...', 'info');

                // Analyze each sentence
                const results_data = sentences.map((sentence, index) => {
                    const sentenceEmbedding = sentenceEmbeddings[index];
                    const leftSimilarity = cosineSimilarity(sentenceEmbedding, leftEmbedding);
                    const rightSimilarity = cosineSimilarity(sentenceEmbedding, rightEmbedding);
                    
                    // Calculate position on spectrum (-1 for left, +1 for right)
                    // Use the difference in similarities to determine position
                    const simDiff = rightSimilarity - leftSimilarity;
                    const maxSim = Math.max(Math.abs(leftSimilarity), Math.abs(rightSimilarity));
                    const position = maxSim > 0 ? simDiff / maxSim : 0;
                    
                    return {
                        text: sentence,
                        position: position,
                        leftSimilarity: leftSimilarity,
                        rightSimilarity: rightSimilarity
                    };
                });

                // Display results
                displayResults(results_data, leftSpectrum, rightSpectrum);
                results.style.display = 'block';
                results.scrollIntoView({ behavior: 'smooth' });
                
                showStatus(`Analysis complete! Processed ${sentences.length} sentences.`, 'success');
                setTimeout(hideStatus, 3000);

            } catch (error) {
                console.error('Error during analysis:', error);
                showStatus(`Analysis failed: ${error.message}`, 'error');
            } finally {
                analyzeBtn.textContent = 'Analyze Text';
                analyzeBtn.disabled = false;
                isLoading = false;
            }
        }

        // Display analysis results
        function displayResults(results, leftSpectrum, rightSpectrum) {
            const analyzedText = document.getElementById('analyzedText');
            const legend = document.getElementById('legend');

            // Create legend
            legend.innerHTML = `
                <div class="legend-item">
                    <div class="legend-color" style="background-color: ${getSpectrumColor(-1)}"></div>
                    <span>More "${leftSpectrum}"</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: ${getSpectrumColor(0)}"></div>
                    <span>Neutral</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: ${getSpectrumColor(1)}"></div>
                    <span>More "${rightSpectrum}"</span>
                </div>
            `;

            // Create colored sentences
            analyzedText.innerHTML = results.map(result => {
                const color = getSpectrumColor(result.position);
                const percentage = Math.round(((result.position + 1) / 2) * 100);
                const leftSim = (result.leftSimilarity * 100).toFixed(1);
                const rightSim = (result.rightSimilarity * 100).toFixed(1);
                
                return `<span class="sentence" style="background-color: ${color}" title="Position: ${percentage}% towards '${rightSpectrum}'\nSimilarity to '${leftSpectrum}': ${leftSim}%\nSimilarity to '${rightSpectrum}': ${rightSim}%">${result.text}</span>`;
            }).join(' ');
        }

        // Event listeners
        document.getElementById('analyzeBtn').addEventListener('click', analyzeText);
        document.getElementById('leftSpectrum').addEventListener('input', updateSpectrumLabels);
        document.getElementById('rightSpectrum').addEventListener('input', updateSpectrumLabels);

        // Enter key support for inputs
        document.getElementById('leftSpectrum').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') analyzeText();
        });
        document.getElementById('rightSpectrum').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') analyzeText();
        });

        // Initialize
        updateSpectrumLabels();
        
        // Initialize modal functionality
        function initializeModal() {
            const modal = document.getElementById('howItWorksModal');
            const howItWorksBtn = document.getElementById('howItWorksBtn');
            const closeBtn = document.getElementById('closeModal');
            
            console.log('Initializing modal...', { modal, howItWorksBtn, closeBtn });
            
            if (howItWorksBtn) {
                howItWorksBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('How It Works button clicked');
                    if (modal) {
                        modal.style.display = 'block';
                        document.body.style.overflow = 'hidden';
                    }
                });
            }
            
            if (closeBtn) {
                closeBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('Close button clicked');
                    if (modal) {
                        modal.style.display = 'none';
                        document.body.style.overflow = 'auto';
                    }
                });
            }
            
            if (modal) {
                // Close modal when clicking outside
                modal.addEventListener('click', function(event) {
                    if (event.target === modal) {
                        console.log('Modal background clicked');
                        modal.style.display = 'none';
                        document.body.style.overflow = 'auto';
                    }
                });
            }
            
            // Close modal with Escape key
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape' && modal && modal.style.display === 'block') {
                    console.log('Escape key pressed');
                    modal.style.display = 'none';
                    document.body.style.overflow = 'auto';
                }
            });
        }
        
        // Check if TensorFlow.js and USE are available
        window.addEventListener('load', function() {
            // Initialize modal first
            initializeModal();
            
            if (typeof tf === 'undefined') {
                showStatus('TensorFlow.js failed to load. Please check your internet connection.', 'error');
            } else if (typeof use === 'undefined') {
                showStatus('Universal Sentence Encoder failed to load. Please check your internet connection.', 'error');
            } else {
                showStatus('Libraries loaded successfully. Ready to analyze!', 'success');
                setTimeout(hideStatus, 3000);
                
                // Pre-load model after a short delay for better UX
                setTimeout(() => {
                    if (!model && !isLoading) {
                        loadModel().catch(console.error);
                    }
                }, 2000);
            }
        });
        
        // Also initialize modal when DOM is ready (backup)
        document.addEventListener('DOMContentLoaded', initializeModal);
    </script>
</body>
</html>