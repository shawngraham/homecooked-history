<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Harris Matrix Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        :root {
            --primary-bg: #f0f2f5; --container-bg: #ffffff; --panel-bg: #f8f9fa;
            --header-color: #2c3e50; --text-color: #34495e; --border-color: #dee2e6;
            --primary-accent: #007bff; --primary-accent-hover: #0056b3;
            --danger-accent: #dc3545; --success-accent: #28a745; --warning-accent: #ffc107;
            --cancel-accent: #6c757d; --phase-1: #e3f2fd; --phase-2: #f3e5f5; --phase-3: #e8f5e8;
            --group-bg: #fff3e0; --subgroup-bg: #fafafa;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            margin: 0; padding: 20px; background-color: var(--primary-bg); color: var(--text-color);
        }
        .container {
            max-width: 1800px; margin: 0 auto; background: var(--container-bg);
            border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); padding: 25px;
        }
        .header { text-align: center; margin-bottom: 25px; }
        h1 { color: var(--header-color); margin: 0 0 5px 0; font-size: 2em; }
        .header p { color: #6c757d; margin: 0; }
        .workspace { display: flex; gap: 20px; flex-wrap: wrap; }
        .data-panel {
            width: 400px; background: var(--panel-bg); padding: 20px;
            border-radius: 8px; border: 1px solid var(--border-color);
            height: fit-content; flex-shrink: 0; max-height: 80vh; overflow-y: auto;
        }
        .data-panel h3 { 
            margin: 0 0 15px 0; color: var(--header-color); 
            border-bottom: 1px solid var(--border-color); padding-bottom: 10px; 
        }
        .visualization-panel {
            flex: 1; border: 1px solid var(--border-color); border-radius: 8px;
            min-height: 70vh; position: relative; cursor: grab; overflow: hidden;
        }
        #matrixSvg { display: block; width: 100%; height: 100%; }
        
        /* Context Styles */
        .context-node-group { cursor: move; }
        .context-node-group.dragging { opacity: 0.7; cursor: grabbing; }
        .context-node {
            fill: var(--primary-accent); stroke: var(--primary-accent-hover); stroke-width: 2px;
            cursor: pointer; transition: fill 0.2s, transform 0.2s ease-out;
        }
        .context-node:hover { fill: var(--primary-accent-hover); transform: scale(1.05); }
        .context-node.grouped { fill: var(--warning-accent); stroke: #e0a800; }
        .context-node.phased { fill: var(--success-accent); stroke: #1e7e34; }
        .context-node.temporal-conflict { fill: var(--danger-accent); stroke: #c82333; animation: pulse 2s infinite; }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* Group and Phase Visualization */
        .group-boundary {
            fill: var(--group-bg); stroke: #ff9800; stroke-width: 2px; 
            stroke-dasharray: 5,5; opacity: 0.3; pointer-events: none;
        }
        .subgroup-boundary {
            fill: var(--subgroup-bg); stroke: #9c27b0; stroke-width: 1px;
            stroke-dasharray: 3,3; opacity: 0.2; pointer-events: none;
        }
        .phase-boundary {
            fill: var(--phase-1); stroke: #4caf50; stroke-width: 3px;
            stroke-dasharray: 10,5; opacity: 0.4; pointer-events: none;
        }
        
        .context-label { font-size: 14px; font-weight: 600; text-anchor: middle; pointer-events: none; fill: white; }
        .relationship-path { fill: none; stroke-linejoin: round; stroke-linecap: round; }
        .relationship-path.stratigraphic { stroke: #495057; stroke-width: 2px; marker-end: url(#arrowhead); }
        .relationship-path.cuts { stroke: var(--danger-accent); stroke-width: 2.5px; stroke-dasharray: 6,4; marker-end: url(#arrowhead-cuts); }
        .relationship-path.contemporary { stroke: #495057; stroke-width: 1.5px; }
        .relationship-path.temporal-conflict { stroke: var(--danger-accent); stroke-width: 3px; animation: pulse 2s infinite; marker-end: url(#arrowhead-cuts); }
        .relationship-path.redundant { stroke: #adb5bd; stroke-width: 1.5px; stroke-dasharray: 2, 3; marker-end: url(#arrowhead-redundant); }
        
        /* Modal Styles */
        .modal-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1000;
        }
        .modal-content {
            background: white; padding: 25px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            width: 400px; max-height: 80vh; overflow-y: auto;
        }
        .modal-content h4 { margin: 0 0 20px 0; }
        .modal-content input, .modal-content select, .modal-content textarea { 
            width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid var(--border-color); 
            border-radius: 4px; box-sizing: border-box; 
        }
        .modal-buttons { display: flex; justify-content: space-between; gap: 10px; margin-top: 20px; }
        .modal-buttons button { flex: 1; padding: 10px; border: none; border-radius: 4px; cursor: pointer; color: white; }
        .modal-buttons button.confirm { background: var(--primary-accent); }
        .modal-buttons button.danger { background: var(--danger-accent); }
        .modal-buttons button.cancel { background: var(--cancel-accent); }
        
        /* Form Styles */
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: 600; }
        .form-row { display: flex; gap: 10px; }
        .form-row input { flex: 1; }
        .date-inputs { display: grid; grid-template-columns: 2fr 1fr; gap: 10px; }
        
        /* Data Display Styles */
        .hierarchy-list { margin-bottom: 20px; }
        .hierarchy-item {
            padding: 10px; margin: 5px 0; border-radius: 4px; border-left: 4px solid var(--primary-accent);
            background: #f8f9fa; cursor: pointer; transition: background 0.2s;
        }
        .hierarchy-item:hover { background: #e9ecef; }
        .hierarchy-item.group { border-left-color: #ff9800; background: var(--group-bg); }
        .hierarchy-item.subgroup { border-left-color: #9c27b0; background: var(--subgroup-bg); margin-left: 20px; }
        .hierarchy-item.phase { border-left-color: #4caf50; background: var(--phase-1); }
        .hierarchy-item.temporal-conflict { border-left-color: var(--danger-accent); background: #ffebee; }
        
        .item-header { font-weight: bold; margin-bottom: 5px; }
        .item-details { font-size: 0.9em; color: #666; }
        .item-contexts { font-size: 0.8em; color: #888; margin-top: 5px; }
        
        /* Actions Panel */
        .actions-panel { margin-top: 20px; }
        .actions-panel button { 
            width: 100%; margin-bottom: 10px; padding: 10px; border: none; 
            color: white; border-radius: 5px; cursor: pointer; 
        }
        .btn-primary { background: var(--primary-accent); }
        .btn-success { background: var(--success-accent); }
        .btn-danger { background: var(--danger-accent); }
        .btn-warning { background: var(--warning-accent); color: #333; }
        
        /* Conflict Indicators */
        .conflict-indicator {
            display: inline-block; width: 12px; height: 12px; border-radius: 50%;
            background: var(--danger-accent); margin-left: 5px; animation: pulse 2s infinite;
        }
        .valid-indicator {
            display: inline-block; width: 12px; height: 12px; border-radius: 50%;
            background: var(--success-accent); margin-left: 5px;
        }
        
        /* Tabs */
        .tabs {
            display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 15px;
        }
        .tab {
            padding: 10px 15px; cursor: pointer; border-bottom: 2px solid transparent;
            transition: border-color 0.2s;
        }
        .tab.active { border-bottom-color: var(--primary-accent); background: #f8f9fa; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Graham's Harris Matrix Tool</h1>
            <p>Archaeological stratigraphy data entry tool and visualizer with hierarchical grouping and temporal validation</p>
            <p style="font-size: 12px; font-style: italic;">Click background to create contexts • Drag contexts to create relationships • Click on contexts to edit • Scroll to zoom, drag background to pan</p>
        </div>
        
        <div class="workspace">
            <div class="data-panel">
                <div class="tabs">
                    <div class="tab active" onclick="switchTab('hierarchy')">Hierarchy</div>
                    <div class="tab" onclick="switchTab('conflicts')">Conflicts</div>
                    <div class="tab" onclick="switchTab('relationships')">Relations</div>
                </div>
                
                <div id="hierarchy-tab" class="tab-content active">
                    <h3>Stratigraphic Hierarchy</h3>
                    <div id="hierarchyList"><em>No data yet. Start by clicking on the canvas.</em></div>
                </div>
                
                <div id="conflicts-tab" class="tab-content">
                    <h3>Temporal Conflicts</h3>
                    <div id="conflictsList"><em>No conflicts detected.</em></div>
                </div>
                
                <div id="relationships-tab" class="tab-content">
                    <h3>Relationships</h3>
                    <div id="relationshipsList"><em>No relationships defined.</em></div>
                </div>
                
                <div class="actions-panel">
                    <button onclick="resetZoom()" class="btn-primary">Reset View</button>
                    <h3>Management Tools</h3>
                    <button onclick="createGroup()" class="btn-warning">Create Group</button>
                    <button onclick="createSubGroup()" class="btn-warning">Create Sub-Group</button>
                    <button onclick="createPhase()" class="btn-success">Create Phase</button>
                    <button onclick="analyzeTemporalConflicts()" class="btn-primary">Analyze Conflicts</button>
                    <h3>Import/Export</h3>
                    <button onclick="exportEnhancedData()" class="btn-primary">Export Enhanced CSV</button>
                    <button onclick="exportViewAsSVG()" class="btn-primary">Export View as SVG</button>
                    <button onclick="triggerImport()" class="btn-primary">Import from CSV</button>
                    <h3>Start Over</h3>
                    <button onclick="confirmClear()" class="btn-danger">Clear All</button>
                </div>
            </div>
            
            <div class="visualization-panel">
                <svg id="matrixSvg"></svg>
            </div>
        </div>
    </div>
    
    <input type="file" id="csvFileInput" accept=".csv" style="display:none;">

    <!-- CSV Import Modal -->
    <div id="importModal" class="modal-backdrop">
        <div class="modal-content">
            <h4>Map CSV Columns to Import</h4>
            <p style="font-size:0.9em; margin-bottom:15px;">
               Select which column from your CSV file corresponds to each data field.
               <b>Context ID</b> is required for each row. Relationships require both a <b>Related Context ID</b> and a <b>Relationship Type</b>.
            </p>
    
            <div class="form-group">
                <label>Context ID (Required)</label>
                <select id="mapContextId"></select>
            </div>
            <div class="form-group">
                <label>Description</label>
                <select id="mapDescription"></select>
            </div>
            
            <hr style="margin: 20px 0;">
            <h5 style="margin-bottom:15px;">For Relationships</h5>
    
            <div class="form-group">
                <label>Relationship Type (e.g., 'above', 'below', 'equivalent')</label>
                <select id="mapRelType"></select>
            </div>
            <div class="form-group">
                <label>Related Context ID</label>
                <select id="mapRelTo"></select>
            </div>
            
            <hr style="margin: 20px 0;">
            <div class="form-group">
                <label><input type="checkbox" id="importClearData" checked> Clear all existing data before import</label>
            </div>
    
            <div class="modal-buttons">
                <button id="confirmImportBtn" class="confirm">Import Data</button>
                <button onclick="hideModals()" class="cancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Enhanced Context Modal -->
    <div id="contextModal" class="modal-backdrop">
        <div class="modal-content">
            <h4>Create New Context</h4>
            <div class="form-group">
                <label>Context Identifier</label>
                <input type="text" id="newContextId" placeholder="e.g., 1001">
            </div>
            <div class="form-group">
                <label>Context Type</label>
                <select id="contextType">
                    <option value="layer">Layer</option>
                    <option value="deposit">Deposit</option>
                    <option value="cut">Cut</option>
                    <option value="fill">Fill</option>
                    <option value="structure">Structure</option>
                    <option value="interface">Interface</option>
                </select>
            </div>
            <div class="form-group">
                <label>Description</label>
                <textarea id="contextDescription" placeholder="Brief description of the context" rows="2"></textarea>
            </div>
            <div class="form-group">
                <label>Dating Evidence (optional)</label>
                
                <label style="font-size:0.9em; font-weight:normal; margin-top: 5px;">Earliest Date</label>
                <div class="date-inputs">
                    <input type="number" id="earliestDateYear" placeholder="Year" min="1">
                    <select id="earliestDateEra">
                        <option value="CE">CE</option>
                        <option value="BCE">BCE</option>
                    </select>
                </div>

                <label style="font-size:0.9em; font-weight:normal; margin-top: 5px;">Latest Date</label>
                <div class="date-inputs">
                    <input type="number" id="latestDateYear" placeholder="Year" min="1">
                    <select id="latestDateEra">
                        <option value="CE">CE</option>
                        <option value="BCE">BCE</option>
                    </select>
                </div>

                <select id="dateType" style="margin-top: 10px;">
                    <option value="">No dating evidence</option>
                    <option value="pottery">Pottery</option>
                    <option value="coin">Coin</option>
                    <option value="radiocarbon">Radiocarbon</option>
                    <option value="stratigraphic">Stratigraphic</option>
                    <option value="architectural">Architectural</option>
                </select>
            </div>
            <div class="modal-buttons">
                <button id="confirmContextBtn" class="confirm">Create</button>
                <button onclick="hideModals()" class="cancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Relationship Modal -->
    <div id="relationshipModal" class="modal-backdrop">
        <div class="modal-content">
            <h4 id="relationshipModalTitle">Define Relationship</h4>
            <select id="relationshipType"></select>
            <div class="modal-buttons">
                <button id="confirmRelationshipBtn" class="confirm">Add</button>
                <button onclick="hideModals()" class="cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Edit Node Modal -->
    <div id="editNodeModal" class="modal-backdrop">
        <div class="modal-content">
            <h4 id="editNodeModalTitle">Edit Context</h4>
            <div class="form-group">
                <label>Context Identifier</label>
                <input type="text" id="editNodeIdInput">
            </div>
            <div class="form-group">
                <label>Context Type</label>
                <select id="editContextType">
                    <option value="layer">Layer</option>
                    <option value="deposit">Deposit</option>
                    <option value="cut">Cut</option>
                    <option value="fill">Fill</option>
                    <option value="structure">Structure</option>
                    <option value="interface">Interface</option>
                </select>
            </div>
            <div class="form-group">
                <label>Description</label>
                <textarea id="editContextDescription" rows="2"></textarea>
            </div>
            <div class="form-group">
                <label>Dating Evidence</label>
                
                <label style="font-size:0.9em; font-weight:normal; margin-top: 5px;">Earliest Date</label>
                <div class="date-inputs">
                    <input type="number" id="editEarliestDateYear" placeholder="Year" min="1">
                    <select id="editEarliestDateEra">
                        <option value="CE">CE</option>
                        <option value="BCE">BCE</option>
                    </select>
                </div>

                <label style="font-size:0.9em; font-weight:normal; margin-top: 5px;">Latest Date</label>
                <div class="date-inputs">
                    <input type="number" id="editLatestDateYear" placeholder="Year" min="1">
                    <select id="editLatestDateEra">
                        <option value="CE">CE</option>
                        <option value="BCE">BCE</option>
                    </select>
                </div>

                <select id="editDateType" style="margin-top: 10px;">
                    <option value="">No dating evidence</option>
                    <option value="pottery">Pottery</option>
                    <option value="coin">Coin</option>
                    <option value="radiocarbon">Radiocarbon</option>
                    <option value="stratigraphic">Stratigraphic</option>
                    <option value="architectural">Architectural</option>
                </select>
            </div>
             <div class="form-group">
                <label>Phase Assignment</label>
                <select id="editPhaseAssignment">
                    <option value="">No phase</option>
                </select>
            </div>
            <div class="form-group">
                <label>Group Assignment</label>
                <select id="editGroupAssignment">
                    <option value="">No group</option>
                </select>
            </div>
            <div class="form-group">
                <label>Sub-Group Assignment</label>
                <select id="editSubGroupAssignment">
                    <option value="">No sub-group</option>
                </select>
            </div>
            <div class="modal-buttons">
                <button id="saveNodeBtn" class="confirm">Save Changes</button>
                <button onclick="hideModals()" class="cancel">Cancel</button>
            </div>
            <button id="deleteNodeBtn" class="danger" style="width: 100%; margin-top: 10px;">Delete Context</button>
        </div>
    </div>

    <!-- Group Creation Modal -->
    <div id="groupModal" class="modal-backdrop">
        <div class="modal-content">
            <h4 id="groupModalTitle">Create Group</h4>
            <div class="form-group">
                <label>Name</label>
                <input type="text" id="groupName" placeholder="e.g., Building A">
            </div>
            <div class="form-group">
                <label>Description</label>
                <textarea id="groupDescription" placeholder="Description of the item" rows="2"></textarea>
            </div>
            <div class="form-group" id="groupTypeWrapper">
                <label>Group Type</label>
                <select id="groupType">
                    <option value="functional">Functional Group</option>
                    <option value="structural">Structural Group</option>
                    <option value="chronological">Chronological Group</option>
                    <option value="spatial">Spatial Group</option>
                </select>
            </div>
            <div class="modal-buttons">
                <button id="confirmGroupBtn" class="confirm">Create</button>
                <button onclick="hideModals()" class="cancel">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Data Model
        let contexts = new Map();
        let relationships = [];
        let groups = new Map();
        let subGroups = new Map();
        let phases = new Map();
        let nodePositions = {};
        let temporalConflicts = [];

        // D3 Setup
        const svg = d3.select("#matrixSvg");
        const g = svg.append("g").attr("class", "main-group");
        const GRID_CELL_SIZE = 60;
        const GRID_COLOR = "#e9ecef";
        const zoom = d3.zoom().scaleExtent([0.1, 5]).on("zoom", (event) => g.attr("transform", event.transform));
        svg.call(zoom);

        // Data Structure Classes
        class ArchaeologicalContext {
            constructor(id, x = 0, y = 0) {
                this.id = id; this.x = x; this.y = y; this.fixed = false; this.type = 'layer';
                this.description = ''; this.earliestDate = null; this.latestDate = null; this.dateType = '';
                this.groupId = null; this.subGroupId = null; this.phaseId = null;
            }
            hasDateRange() { return this.earliestDate !== null && this.latestDate !== null; }
            getDateRange() { if (!this.hasDateRange()) return null; return { earliest: this.earliestDate, latest: this.latestDate, type: this.dateType }; }
        }
        class HierarchicalGroup {
            constructor(id, name, type = 'functional') {
                this.id = id; this.name = name; this.type = type; this.description = '';
                this.contexts = new Set(); this.subGroups = new Set(); this.phaseId = null;
            }
        }

        // --- Core Application Logic ---
        window.onload = () => {
            loadFromStorage();
            drawGrid();
            updateUI();
            svg.on('click', handleCanvasClick);
            document.getElementById('csvFileInput').onchange = handleFileSelect;
        };
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.querySelector(`.tab[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }

        function updateUI() {
            updateHierarchyDisplay();
            updateConflictsDisplay();
            updateRelationshipsDisplay();
            updateDropdownOptions();
            applySugiyamaLayout();
            saveToStorage();
        }

        function applySugiyamaLayout() {
            if (contexts.size === 0) { g.selectAll(".context-node-group, .relationship-path, .group-boundary, .subgroup-boundary, .phase-boundary").remove(); return; }
            const { levels, stratigraphicEdges, contemporaryLinks, hasCycle } = calculateInitialLevels();

            if (hasCycle) {
                const cyclicNodeIds = Array.from(contexts.keys()).filter(id => !levels.has(id));
                alert(`ERROR: A cycle was detected in the stratigraphic relationships, which is logically impossible.\n\nPlease review the relationships for the following contexts:\n\n${cyclicNodeIds.join(', ')}\n\nThe matrix cannot be drawn until this is fixed.`);
                return;
            }

            const { dummyNodes, allEdges } = createDummyNodesAndEdges(stratigraphicEdges, levels);
            const allNodes = new Map([...contexts, ...dummyNodes]);
            const orderedLevels = reduceCrossings(levels, allNodes, allEdges);
            nodePositions = assignCoordinates(orderedLevels, levels, dummyNodes);
            drawMatrix(nodePositions, allEdges, contemporaryLinks);
        }

        // --- Display and UI Panel Updates ---
        function updateHierarchyDisplay() {
            const listDiv = document.getElementById("hierarchyList");
            let html = '';
            
            if (phases.size > 0) {
                html += '<div style="font-weight: bold; margin: 10px 0;">Phases</div>';
                phases.forEach(phase => {
                    const phaseContextIds = Array.from(contexts.values()).filter(c => c.phaseId === phase.id).map(c => c.id);
                    const hasConflicts = temporalConflicts.some(c => phaseContextIds.includes(c.context1) || phaseContextIds.includes(c.context2));
                    html += `<div class="hierarchy-item phase ${hasConflicts ? 'temporal-conflict' : ''}" onclick="highlightPhase('${phase.id}')"><div class="item-header">Phase: ${phase.name}${hasConflicts ? '<span class="conflict-indicator"></span>' : '<span class="valid-indicator"></span>'}</div><div class="item-details">${phase.description}</div><div class="item-contexts">${phaseContextIds.length} contexts</div></div>`;
                });
            }
            
            if (groups.size > 0) {
                html += '<div style="font-weight: bold; margin: 10px 0;">Groups</div>';
                groups.forEach(group => {
                    const groupContextIds = Array.from(group.contexts);
                    const hasConflicts = temporalConflicts.some(c => groupContextIds.includes(c.context1) || groupContextIds.includes(c.context2));
                    html += `<div class="hierarchy-item group ${hasConflicts ? 'temporal-conflict' : ''}" onclick="highlightGroup('${group.id}')"><div class="item-header">Group: ${group.name} (${group.type})${hasConflicts ? '<span class="conflict-indicator"></span>' : '<span class="valid-indicator"></span>'}</div><div class="item-details">${group.description}</div><div class="item-contexts">${group.contexts.size} contexts</div></div>`;
                    group.subGroups.forEach(subGroupId => {
                        const subGroup = subGroups.get(subGroupId);
                        if (subGroup) {
                             html += `<div class="hierarchy-item subgroup" onclick="highlightSubGroup('${subGroup.id}')"><div class="item-header">Sub-group: ${subGroup.name}</div><div class="item-details">${subGroup.description}</div><div class="item-contexts">${subGroup.contexts.size} contexts</div></div>`;
                        }
                    });
                });
            }
            
            const unassigned = Array.from(contexts.values()).filter(c => !c.groupId && !c.phaseId);
            if (unassigned.length > 0) {
                html += '<div style="font-weight: bold; margin: 10px 0;">Unassigned Contexts</div>';
                unassigned.forEach(context => {
                    const hasConflicts = temporalConflicts.some(c => c.context1 === context.id || c.context2 === context.id);
                    html += `<div class="hierarchy-item ${hasConflicts ? 'temporal-conflict' : ''}" onclick="highlightContext('${context.id}')"><div class="item-header">${context.id} (${context.type})${hasConflicts ? '<span class="conflict-indicator"></span>' : ''}</div><div class="item-details">${context.description}</div>${context.hasDateRange() ? `<div class="item-contexts">${dateToString(context.earliestDate)} - ${dateToString(context.latestDate)} (${context.dateType})</div>` : ''}</div>`;
                });
            }
            listDiv.innerHTML = html || '<em>No data yet. Start by clicking on the canvas.</em>';
        }

        function updateConflictsDisplay() {
            const listDiv = document.getElementById("conflictsList");
            if (temporalConflicts.length === 0) { listDiv.innerHTML = '<em>No conflicts detected.</em>'; return; }
            let html = '';
            temporalConflicts.forEach((conflict, index) => {
                const ctx1 = contexts.get(conflict.context1);
                const ctx2 = contexts.get(conflict.context2);
                html += `<div class="hierarchy-item temporal-conflict"><div class="item-header">Conflict ${index + 1}</div><div class="item-details" style="font-weight: 500;">${conflict.description}</div><div class="item-contexts">${ctx1?.id} (${dateToString(ctx1?.earliestDate)}-${dateToString(ctx1?.latestDate)}) vs ${ctx2?.id} (${dateToString(ctx2?.earliestDate)}-${dateToString(ctx2?.latestDate)})</div></div>`;
            });
            listDiv.innerHTML = html;
        }

        function updateRelationshipsDisplay() {
            const listDiv = document.getElementById("relationshipsList");
            if (relationships.length === 0) { listDiv.innerHTML = '<em>No relationships defined.</em>'; return; }
            const redundantIndices = findRedundantRelationships();
            let tableHTML = `<table style="width:100%; border-collapse: collapse; font-size: 12px;"><thead><tr><th>From</th><th>Relationship</th><th>To</th><th>Status</th><th></th></tr></thead><tbody>`;
            relationships.forEach((rel, index) => {
                const conflict = temporalConflicts.find(c => (c.context1 === rel.from && c.context2 === rel.to) || (c.context1 === rel.to && c.context2 === rel.from));
                const isRedundant = redundantIndices.has(index);
                const status = conflict ? '⚠️ Conflict' : (isRedundant ? 'ℹ️ Redundant' : '✅ Valid');
                const style = conflict ? 'background: #ffebee;' : (isRedundant ? 'background: #f8f9fa; color: #6c757d;' : '');
                tableHTML += `<tr style="${style}"><td style="border: 1px solid #ddd; padding: 4px;">${rel.from}</td><td style="border: 1px solid #ddd; padding: 4px;">${rel.type.replace(/_/g, " ")}</td><td style="border: 1px solid #ddd; padding: 4px;">${rel.to}</td><td style="border: 1px solid #ddd; padding: 4px; text-align: center;">${status}</td><td style="border: 1px solid #ddd; padding: 4px; text-align: center;"><button onclick="removeRelationship(${index})" style="background: var(--danger-accent); color: white; border: none; border-radius: 3px; cursor: pointer; padding: 2px 5px; font-size: 10px;">X</button></td></tr>`;
            });
            tableHTML += `</tbody></table>`;
            listDiv.innerHTML = tableHTML;
        }
        
        function updateDropdownOptions() {
             ['editGroupAssignment', 'editSubGroupAssignment', 'editPhaseAssignment'].forEach(id => {
                const select = document.getElementById(id);
                const currentVal = select.value;
                if (id === 'editGroupAssignment') {
                    select.innerHTML = '<option value="">No group</option>';
                    groups.forEach(group => { select.innerHTML += `<option value="${group.id}">${group.name}</option>`; });
                } else if (id === 'editSubGroupAssignment') {
                    select.innerHTML = '<option value="">No sub-group</option>';
                    subGroups.forEach(subGroup => { select.innerHTML += `<option value="${subGroup.id}">${subGroup.name}</option>`; });
                } else {
                    select.innerHTML = '<option value="">No phase</option>';
                    phases.forEach(phase => { select.innerHTML += `<option value="${phase.id}">${phase.name}</option>`; });
                }
                select.value = currentVal;
            });
        }

        // --- Analysis and Validation ---
        function analyzeTemporalConflicts() {
            temporalConflicts = [];
            relationships.forEach(rel => {
                const ctx1 = contexts.get(rel.from);
                const ctx2 = contexts.get(rel.to);
                if (!ctx1?.hasDateRange() || !ctx2?.hasDateRange()) return;
                let earlierCtx, laterCtx, earlierDate, laterDate;
                if (['above', 'seals', 'cuts', 'filled_by'].includes(rel.type)) { [earlierCtx, laterCtx] = [ctx2, ctx1]; } 
                else if (['below', 'sealed_by', 'cut_by', 'fill_of'].includes(rel.type)) { [earlierCtx, laterCtx] = [ctx1, ctx2]; } 
                else { return; }
                earlierDate = earlierCtx.getDateRange();
                laterDate = laterCtx.getDateRange();
                if (earlierDate.earliest > laterDate.latest) {
                    temporalConflicts.push({ context1: earlierCtx.id, context2: laterCtx.id, description: `IMPOSSIBLE: ${earlierCtx.id} (earlier) is dated entirely after ${laterCtx.id} (later).` });
                }
            });
            updateUI();
            alert(`Analysis complete. Found ${temporalConflicts.length} irreconcilable temporal conflicts.`);
        }

        function findRedundantRelationships() {
            const redundantIndices = new Set();
            const { stratigraphicEdges } = calculateInitialLevels();
            if (!stratigraphicEdges) return redundantIndices;
            const adj = new Map();
            stratigraphicEdges.forEach(edge => {
                if (!adj.has(edge.from)) adj.set(edge.from, []);
                adj.get(edge.from).push(edge.to);
            });
            const hasPath = (start, end, ignoredEdge) => {
                const stack = [start];
                const visited = new Set([start]);
                while (stack.length > 0) {
                    const u = stack.pop();
                    if (u === end) return true;
                    for (const v of (adj.get(u) || [])) {
                        if (u === ignoredEdge.from && v === ignoredEdge.to) continue;
                        if (!visited.has(v)) { visited.add(v); stack.push(v); }
                    }
                }
                return false;
            };
            stratigraphicEdges.forEach(edge => {
                if (hasPath(edge.from, edge.to, edge)) {
                    redundantIndices.add(edge.originalIndex);
                }
            });
            return redundantIndices;
        }

        // --- Layout Algorithm Functions ---
        function findEquivalenceGroups(contexts, relationships) {
            const adj = new Map(Array.from(contexts.keys()).map(id => [id, []]));
            relationships.forEach(rel => {
                if (['contemporary_with', 'equivalent', 'same_as'].includes(rel.type)) {
                    adj.get(rel.from)?.push(rel.to);
                    adj.get(rel.to)?.push(rel.from);
                }
            });

            const visited = new Set();
            const contextToGroupRep = new Map();
            const groupRepToMembers = new Map();

            for (const contextId of contexts.keys()) {
                if (!visited.has(contextId)) {
                    const groupMembers = new Set();
                    const queue = [contextId];
                    visited.add(contextId);
                    
                    while (queue.length > 0) {
                        const u = queue.shift();
                        groupMembers.add(u);
                        (adj.get(u) || []).forEach(v => {
                            if (!visited.has(v)) {
                                visited.add(v);
                                queue.push(v);
                            }
                        });
                    }

                    if (groupMembers.size > 1) {
                        const representative = contextId;
                        groupRepToMembers.set(representative, groupMembers);
                        groupMembers.forEach(memberId => {
                            contextToGroupRep.set(memberId, representative);
                        });
                    }
                }
            }
            return { contextToGroupRep, groupRepToMembers };
        }

        function calculateInitialLevels() {
            const contextIds = Array.from(contexts.keys());
            if (contextIds.length === 0) return { levels: new Map(), stratigraphicEdges: [], contemporaryLinks: [], hasCycle: false, equivalenceInfo: { contextToGroupRep: new Map(), groupRepToMembers: new Map() } };
            
            const equivalenceInfo = findEquivalenceGroups(contexts, relationships);
            const { contextToGroupRep } = equivalenceInfo;
            
            const logicalNodes = new Set(contextIds.map(id => contextToGroupRep.get(id) || id));
            const adj = new Map(Array.from(logicalNodes).map(id => [id, []]));
            const inDegree = new Map(Array.from(logicalNodes).map(id => [id, 0]));
            const stratigraphicEdges = [];
            const contemporaryLinks = [];

            relationships.forEach((rel, index) => {
                let from, to;
                if (['above', 'seals', 'cuts', 'fill_of'].includes(rel.type)) { [from, to] = [rel.to, rel.from]; } 
                else if (['below', 'sealed_by', 'cut_by', 'filled_by'].includes(rel.type)) { [from, to] = [rel.from, rel.to]; } 
                else if (['contemporary_with', 'equivalent', 'same_as'].includes(rel.type)) { contemporaryLinks.push({ from: rel.from, to: rel.to }); }
                if (from && to && contexts.has(from) && contexts.has(to)) {
                    const repFrom = contextToGroupRep.get(from) || from;
                    const repTo = contextToGroupRep.get(to) || to;

                    if (repFrom !== repTo) {
                        if (!adj.get(repFrom)?.includes(repTo)) {
                           adj.get(repFrom)?.push(repTo);
                           inDegree.set(repTo, (inDegree.get(repTo) || 0) + 1);
                        }
                    }
                    stratigraphicEdges.push({ from, to, isCut: ['cuts', 'cut_by'].includes(rel.type), originalIndex: index });
                }
            });

            const levels = new Map();
            const queue = Array.from(logicalNodes).filter(id => inDegree.get(id) === 0);
            const processedLogicalNodes = [];
            for (let i = 0; i < queue.length; i++) {
                const u_rep = queue[i];
                processedLogicalNodes.push(u_rep);
                levels.set(u_rep, levels.get(u_rep) || 0);
                (adj.get(u_rep) || []).forEach(v_rep => {
                    levels.set(v_rep, Math.max(levels.get(v_rep) || 0, levels.get(u_rep) + 1));
                    inDegree.set(v_rep, inDegree.get(v_rep) - 1);
                    if (inDegree.get(v_rep) === 0) queue.push(v_rep);
                });
            }

            const hasCycle = processedLogicalNodes.length < logicalNodes.size;
            const finalLevels = new Map();
            if (!hasCycle) {
                contextIds.forEach(id => {
                    const rep = contextToGroupRep.get(id) || id;
                    finalLevels.set(id, levels.get(rep) || 0);
                });
            }
            return { levels: finalLevels, stratigraphicEdges, contemporaryLinks, hasCycle, equivalenceInfo };
        }

        function createDummyNodesAndEdges(edges, levels) {
            const dummyNodes = new Map();
            const allEdges = [];
            edges.forEach(edge => {
                const fromLevel = levels.get(edge.from);
                const toLevel = levels.get(edge.to);
                if (toLevel - fromLevel > 1) {
                    let lastNodeId = edge.from;
                    for (let i = fromLevel + 1; i < toLevel; i++) {
                        const dummyId = `dummy_${edge.from}_${edge.to}_${i}`;
                        dummyNodes.set(dummyId, { id: dummyId, originalSource: edge.from, originalTarget: edge.to });
                        levels.set(dummyId, i);
                        allEdges.push({ from: lastNodeId, to: dummyId, isCut: edge.isCut, originalIndex: edge.originalIndex });
                        lastNodeId = dummyId;
                    }
                    allEdges.push({ from: lastNodeId, to: edge.to, isCut: edge.isCut, originalIndex: edge.originalIndex });
                } else {
                    allEdges.push(edge);
                }
            });
            return { dummyNodes, allEdges };
        }

        function reduceCrossings(levels, allNodes, allEdges) {
            const layerMap = d3.group(Array.from(allNodes.keys()), id => levels.get(id));
            const sortedLayers = Array.from(layerMap.keys()).sort((a, b) => a - b);
            let orderedLevels = new Map(sortedLayers.map(l => [l, layerMap.get(l)]));
            const adj = new Map(Array.from(allNodes.keys()).map(id => [id, []]));
            const revAdj = new Map(Array.from(allNodes.keys()).map(id => [id, []]));
            allEdges.forEach(e => { adj.get(e.from)?.push(e.to); revAdj.get(e.to)?.push(e.from); });
            for (let iter = 0; iter < 10; iter++) {
                for (let i = 1; i < sortedLayers.length; i++) {
                    const layer = orderedLevels.get(sortedLayers[i]);
                    const prevLayer = orderedLevels.get(sortedLayers[i - 1]);
                    const posInPrevLayer = new Map(prevLayer.map((id, idx) => [id, idx]));
                    layer.sort((a, b) => (d3.mean(revAdj.get(a), n => posInPrevLayer.get(n)) ?? -1) - (d3.mean(revAdj.get(b), n => posInPrevLayer.get(n)) ?? -1));
                }
                for (let i = sortedLayers.length - 2; i >= 0; i--) {
                    const layer = orderedLevels.get(sortedLayers[i]);
                    const nextLayer = orderedLevels.get(sortedLayers[i + 1]);
                    const posInNextLayer = new Map(nextLayer.map((id, idx) => [id, idx]));
                    layer.sort((a, b) => (d3.mean(adj.get(a), n => posInNextLayer.get(n)) ?? -1) - (d3.mean(adj.get(b), n => posInNextLayer.get(n)) ?? -1));
                }
            }
            return orderedLevels;
        }

        function assignCoordinates(orderedLevels, levels, dummyNodes) {
            const positions = {};
            const ySpacing = 120, xSpacing = 150;
            const width = svg.node().getBoundingClientRect().width;
            const maxLevel = d3.max(orderedLevels.keys()) || 0;
            const fixedNodeIds = new Set();
            contexts.forEach(context => {
                if (context.fixed) {
                    positions[context.id] = { x: context.x, y: context.y };
                    fixedNodeIds.add(context.id);
                }
            });
            orderedLevels.forEach((nodes, level) => {
                nodes.forEach(id => {
                    const dummyInfo = dummyNodes.get(id);
                    if (dummyInfo && fixedNodeIds.has(dummyInfo.originalSource) && fixedNodeIds.has(dummyInfo.originalTarget)) {
                        const sourcePos = positions[dummyInfo.originalSource];
                        const targetPos = positions[dummyInfo.originalTarget];
                        const sourceLevel = levels.get(dummyInfo.originalSource);
                        const targetLevel = levels.get(dummyInfo.originalTarget);
                        if (targetLevel > sourceLevel) {
                            const progress = (level - sourceLevel) / (targetLevel - sourceLevel);
                            const interpolatedX = sourcePos.x + (targetPos.x - sourcePos.x) * progress;
                            const interpolatedY = sourcePos.y + (targetPos.y - sourcePos.y) * progress;
                            positions[id] = { x: interpolatedX, y: interpolatedY };
                        }
                    }
                });
            });
            const floatingLevels = new Map();
            orderedLevels.forEach((nodes, level) => {
                const floatingNodes = nodes.filter(id => !positions[id]);
                if (floatingNodes.length > 0) floatingLevels.set(level, floatingNodes);
            });
            floatingLevels.forEach((nodes, level) => {
                const levelWidth = (nodes.length - 1) * xSpacing;
                const startX = (width - levelWidth) / 2;
                const yPos = 50 + (maxLevel - level) * ySpacing;
                nodes.forEach((id, i) => {
                    positions[id] = { x: startX + i * xSpacing, y: yPos };
                });
            });
            return positions;
        }

        // --- Drawing Functions ---
        function drawGrid() {
            g.select(".grid-group").remove();
            const gridSize = 4000;
            const gridGroup = g.insert("g", ":first-child").attr("class", "grid-group");
            gridGroup.selectAll("line.vertical").data(d3.range(-gridSize, gridSize, GRID_CELL_SIZE)).enter().append("line").attr("class", "vertical").attr("x1", d => d).attr("y1", -gridSize).attr("x2", d => d).attr("y2", gridSize).style("stroke", GRID_COLOR).style("stroke-width", 1);
            gridGroup.selectAll("line.horizontal").data(d3.range(-gridSize, gridSize, GRID_CELL_SIZE)).enter().append("line").attr("class", "horizontal").attr("x1", -gridSize).attr("y1", d => d).attr("x2", gridSize).attr("y2", d => d).style("stroke", GRID_COLOR).style("stroke-width", 1);
        }
        
        function drawMatrix(positions, allEdges, contemporaryLinks) {
            g.selectAll(".context-node-group, .relationship-path, .group-boundary, .subgroup-boundary, .phase-boundary, defs").remove();
            const defs = g.append("defs");
            defs.append("marker").attr("id", "arrowhead").attr("viewBox", "-2 -5 10 10").attr("refX", 5).attr("refY", 0).attr("markerWidth", 5).attr("markerHeight", 5).attr("orient", "auto").append("path").attr("d", "M0,-5L10,0L0,5").style("fill", "#495057");
            defs.append("marker").attr("id", "arrowhead-cuts").attr("viewBox", "-2 -5 10 10").attr("refX", 5).attr("refY", 0).attr("markerWidth", 5).attr("markerHeight", 5).attr("orient", "auto").append("path").attr("d", "M0,-5L10,0L0,5").style("fill", "var(--danger-accent)");
            defs.append("marker").attr("id", "arrowhead-redundant").attr("viewBox", "-2 -5 10 10").attr("refX", 5).attr("refY", 0).attr("markerWidth", 4).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M0,-5L10,0L0,5").style("fill", "#adb5bd");
            
            drawGroupBoundaries(positions);
            const redundantRelationIndices = findRedundantRelationships();

            const getEdgeClasses = (edge) => {
                const isRedundant = redundantRelationIndices.has(edge.originalIndex);
                if (isRedundant) return 'relationship-path redundant';
                
                const originalRel = relationships[edge.originalIndex];
                if (!originalRel) return 'relationship-path stratigraphic';

                const hasConflict = temporalConflicts.some(c => (c.context1 === originalRel.from && c.context2 === originalRel.to) || (c.context1 === originalRel.to && c.context2 === originalRel.from));
                if (hasConflict) return 'relationship-path temporal-conflict';

                const isCut = ['cuts', 'cut_by'].includes(originalRel.type);
                return `relationship-path ${isCut ? 'cuts' : 'stratigraphic'}`;
            };
            
            const BOX_HALF_HEIGHT = 22.5, BOX_HALF_WIDTH = 45;

            // Draw all stratigraphic relationships with a simple, robust elbow connector.
            allEdges.forEach(edge => {
                const p1 = positions[edge.from];
                const p2 = positions[edge.to];
                if (!p1 || !p2) return;
                
                const startY = p1.y + (contexts.has(edge.from) ? BOX_HALF_HEIGHT : 0);
                const endY = p2.y - (contexts.has(edge.to) ? BOX_HALF_HEIGHT : 0);
                
                const midY = startY + (endY - startY) / 2;
                const pathData = `M ${p1.x},${startY} V ${midY} H ${p2.x} V ${endY}`;
                g.append("path").attr("class", getEdgeClasses(edge)).attr("d", pathData);
            });

            // Draw contemporary links with the double bar.
            contemporaryLinks.forEach(link => {
                const p1 = positions[link.from];
                const p2 = positions[link.to];
                if (!p1 || !p2) return;
                const yOffset = 2.5;
                const x1 = p1.x < p2.x ? p1.x + BOX_HALF_WIDTH : p1.x - BOX_HALF_WIDTH;
                const x2 = p1.x < p2.x ? p2.x - BOX_HALF_WIDTH : p2.x + BOX_HALF_WIDTH;
                g.append("line").attr("class", "relationship-path contemporary").attr("x1", x1).attr("y1", p1.y - yOffset).attr("x2", x2).attr("y2", p2.y - yOffset);
                g.append("line").attr("class", "relationship-path contemporary").attr("x1", x1).attr("y1", p1.y + yOffset).attr("x2", x2).attr("y2", p2.y + yOffset);
            });

            // Draw the nodes on top of the lines.
            const nodeData = Array.from(contexts.keys()).filter(id => positions[id]);
            const nodeGroups = g.selectAll(".context-node-group").data(nodeData, d => d).join("g")
                .attr("class", "context-node-group")
                .attr("transform", d => `translate(${positions[d].x}, ${positions[d].y})`)
                .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));
            nodeGroups.append("rect").attr("class", d => "context-node " + (temporalConflicts.some(c => c.context1 === d || c.context2 === d) ? "temporal-conflict" : (contexts.get(d)?.phaseId ? "phased" : (contexts.get(d)?.groupId ? "grouped" : "")))).attr("x", -BOX_HALF_WIDTH).attr("y", -BOX_HALF_HEIGHT).attr("width", BOX_HALF_WIDTH*2).attr("height", BOX_HALF_HEIGHT*2).attr("rx", 8);
            nodeGroups.append("text").attr("class", "context-label").attr("dy", "0.35em").text(d => d);
        }

        function drawGroupBoundaries(positions) {
            const drawRectBoundary = (contextIds, className) => {
                const validPositions = contextIds.map(id => positions[id]).filter(p => p);
                if (validPositions.length < 1) return;
                const padX = 60; const padY = 40;
                const minX = d3.min(validPositions, p => p.x) - padX; const maxX = d3.max(validPositions, p => p.x) + padX;
                const minY = d3.min(validPositions, p => p.y) - padY; const maxY = d3.max(validPositions, p => p.y) + padY;
                g.insert("rect", ":first-child").attr("class", className).attr("x", minX).attr("y", minY).attr("width", maxX - minX).attr("height", maxY - minY).attr("rx", 15);
            };
            phases.forEach(phase => drawRectBoundary(Array.from(contexts.values()).filter(c => c.phaseId === phase.id).map(c => c.id), 'phase-boundary'));
            groups.forEach(group => drawRectBoundary(Array.from(group.contexts), 'group-boundary'));
            subGroups.forEach(subGroup => drawRectBoundary(Array.from(subGroup.contexts), 'subgroup-boundary'));
        }

        // --- Event Handlers & Modals ---
        let wasDragged = false;
        function handleCanvasClick(event) { if (event.defaultPrevented) return; const [x, y] = d3.pointer(event, g.node()); const snappedX = Math.round(x / GRID_CELL_SIZE) * GRID_CELL_SIZE; const snappedY = Math.round(y / GRID_CELL_SIZE) * GRID_CELL_SIZE; showContextModal(snappedX, snappedY); }
        function dragstarted(event) { event.sourceEvent.stopPropagation(); d3.select(this).raise().classed("dragging", true); wasDragged = false; }
        function dragged(event) { wasDragged = true; d3.select(this).attr("transform", `translate(${event.x}, ${event.y})`); }
        function dragended(event, d) {
            d3.select(this).classed("dragging", false);
            if (wasDragged) {
                const sourceId = d; let targetId = null;
                for (const [id] of contexts.entries()) {
                    if (sourceId === id) continue;
                    const pos = nodePositions[id];
                    if (pos && event.x > pos.x - 45 && event.x < pos.x + 45 && event.y > pos.y - 22.5 && event.y < pos.y + 22.5) { targetId = id; break; }
                }
                if (targetId) { showRelationshipModal(sourceId, targetId); } 
                else { const context = contexts.get(sourceId); if (context) { context.x = Math.round(event.x / GRID_CELL_SIZE) * GRID_CELL_SIZE; context.y = Math.round(event.y / GRID_CELL_SIZE) * GRID_CELL_SIZE; context.fixed = true; } }
                updateUI();
            } else { showEditNodeModal(d); }
        }
        
        function showContextModal(x, y) {
            const modal = document.getElementById("contextModal");
            modal.style.display = "flex";
            const input = document.getElementById("newContextId");
            input.value = suggestNextContextId();
            document.getElementById("earliestDateYear").value = ''; document.getElementById("latestDateYear").value = ''; document.getElementById("contextDescription").value = ''; document.getElementById("dateType").value = ''; input.focus();
            document.getElementById("confirmContextBtn").onclick = () => {
                const id = document.getElementById("newContextId").value.trim().toUpperCase();
                if (!id || contexts.has(id)) { alert(`Context "${id}" is invalid or already exists.`); return; }
                const context = new ArchaeologicalContext(id, x, y);
                context.fixed = true; context.type = document.getElementById("contextType").value; context.description = document.getElementById("contextDescription").value.trim();
                const earliestYear = parseInt(document.getElementById("earliestDateYear").value); const earliestEra = document.getElementById("earliestDateEra").value;
                const latestYear = parseInt(document.getElementById("latestDateYear").value); const latestEra = document.getElementById("latestDateEra").value;
                context.earliestDate = parseDateFromInputs(earliestYear, earliestEra); context.latestDate = parseDateFromInputs(latestYear, latestEra);
                context.dateType = document.getElementById("dateType").value;
                contexts.set(id, context);
                hideModals(); updateUI();
            };
        }

        function showEditNodeModal(contextId) {
            const modal = document.getElementById("editNodeModal"); modal.style.display = "flex"; const context = contexts.get(contextId);
            document.getElementById("editNodeModalTitle").innerText = `Edit Context: ${contextId}`; document.getElementById("editNodeIdInput").value = contextId; document.getElementById("editContextType").value = context.type; document.getElementById("editContextDescription").value = context.description;
            const earliestDisplay = formatDateForDisplay(context.earliestDate); document.getElementById("editEarliestDateYear").value = earliestDisplay.year; document.getElementById("editEarliestDateEra").value = earliestDisplay.era;
            const latestDisplay = formatDateForDisplay(context.latestDate); document.getElementById("editLatestDateYear").value = latestDisplay.year; document.getElementById("editLatestDateEra").value = latestDisplay.era;
            document.getElementById("editDateType").value = context.dateType || ''; document.getElementById("editGroupAssignment").value = context.groupId || ''; document.getElementById("editSubGroupAssignment").value = context.subGroupId || ''; document.getElementById("editPhaseAssignment").value = context.phaseId || '';
            document.getElementById("saveNodeBtn").onclick = () => saveNodeChanges(contextId); document.getElementById("deleteNodeBtn").onclick = () => deleteContext(contextId);
        }

        function saveNodeChanges(oldId) {
            const newId = document.getElementById('editNodeIdInput').value.trim().toUpperCase();
            if (!newId || (newId !== oldId && contexts.has(newId))) { alert("Context ID is invalid or already exists."); return; }
            const context = contexts.get(oldId);
            if (context.groupId) groups.get(context.groupId)?.contexts.delete(oldId); if (context.subGroupId) subGroups.get(context.subGroupId)?.contexts.delete(oldId);
            context.type = document.getElementById('editContextType').value; context.description = document.getElementById('editContextDescription').value.trim();
            const editEarliestYear = parseInt(document.getElementById('editEarliestDateYear').value); const editEarliestEra = document.getElementById('editEarliestDateEra').value;
            const editLatestYear = parseInt(document.getElementById('editLatestDateYear').value); const editLatestEra = document.getElementById('editLatestDateEra').value;
            context.earliestDate = parseDateFromInputs(editEarliestYear, editEarliestEra); context.latestDate = parseDateFromInputs(editLatestYear, editLatestEra); context.dateType = document.getElementById('editDateType').value;
            const newGroupId = document.getElementById('editGroupAssignment').value || null; const newSubGroupId = document.getElementById('editSubGroupAssignment').value || null; const newPhaseId = document.getElementById('editPhaseAssignment').value || null;
            context.groupId = newGroupId; context.subGroupId = newSubGroupId; context.phaseId = newPhaseId;
            if (newId !== oldId) {
                context.id = newId; contexts.set(newId, context); contexts.delete(oldId);
                relationships.forEach(rel => { if (rel.from === oldId) rel.from = newId; if (rel.to === oldId) rel.to = newId; });
            }
            if (newGroupId) { const group = groups.get(newGroupId); group?.contexts.add(newId); if (newSubGroupId) { group?.subGroups.add(newSubGroupId); } }
            if (newSubGroupId) { subGroups.get(newSubGroupId)?.contexts.add(newId); }
            hideModals(); updateUI();
        }

        function showRelationshipModal(sourceId, targetId) {
            const modal = document.getElementById("relationshipModal"); modal.style.display = "flex"; document.getElementById("relationshipModalTitle").innerText = `Define Relationship: ${sourceId} → ${targetId}`; const select = document.getElementById("relationshipType");
            select.innerHTML = `<optgroup label="Direct Pairing"><option value="fill_of">${sourceId} is FILL OF ${targetId}</option><option value="filled_by">${sourceId} is FILLED BY ${targetId}</option></optgroup><optgroup label="Stratigraphic"><option value="above">${sourceId} is ABOVE ${targetId}</option><option value="below">${sourceId} is BELOW ${targetId}</option><option value="seals">${sourceId} SEALS ${targetId}</option><option value="sealed_by">${sourceId} is SEALED BY ${targetId}</option></optgroup><optgroup label="Cutting"><option value="cuts">${sourceId} CUTS ${targetId}</option><option value="cut_by">${sourceId} is CUT BY ${targetId}</option></optgroup><optgroup label="Contemporary"><option value="contemporary_with">Contemporary With</option><option value="equivalent">Equivalent To</option><option value="same_as">Same As</option></optgroup>`;
            document.getElementById("confirmRelationshipBtn").onclick = () => { 
                const context1 = contexts.get(sourceId);
                const context2 = contexts.get(targetId);
                if (context1) context1.fixed = false;
                if (context2) context2.fixed = false;
                relationships.push({ from: sourceId, to: targetId, type: select.value }); hideModals(); updateUI(); 
            };
        }
        
        function createGroup() {
            currentModalType = 'group'; document.getElementById("groupModal").style.display = "flex"; document.getElementById("groupModalTitle").innerText = "Create Group"; document.getElementById("groupTypeWrapper").style.display = 'block'; document.getElementById("groupName").value = ''; document.getElementById("groupDescription").value = ''; document.getElementById("confirmGroupBtn").onclick = confirmCreateGroup;
        }
        function confirmCreateGroup() {
            const name = document.getElementById("groupName").value.trim(); if (!name) { alert("Group name is required."); return; } const id = `group_${Date.now()}`; const group = new HierarchicalGroup(id, name, document.getElementById("groupType").value); group.description = document.getElementById("groupDescription").value.trim(); groups.set(id, group); hideModals(); updateUI();
        }
        function createSubGroup() {
            if (groups.size === 0) { alert("Please create a parent group first."); return; } currentModalType = 'subgroup'; document.getElementById("groupModal").style.display = "flex"; document.getElementById("groupModalTitle").innerText = "Create Sub-Group"; document.getElementById("groupTypeWrapper").style.display = 'none'; document.getElementById("groupName").value = ''; document.getElementById("groupDescription").value = ''; document.getElementById("confirmGroupBtn").onclick = confirmCreateSubGroup;
        }
        function confirmCreateSubGroup() {
            const name = document.getElementById("groupName").value.trim(); if (!name) { alert("Sub-group name is required."); return; } const id = `subgroup_${Date.now()}`; const subGroup = new HierarchicalGroup(id, name, 'subgroup'); subGroup.description = document.getElementById("groupDescription").value.trim(); subGroups.set(id, subGroup); hideModals(); updateUI();
        }
        function createPhase() {
            currentModalType = 'phase'; document.getElementById("groupModal").style.display = "flex"; document.getElementById("groupModalTitle").innerText = "Create Phase"; document.getElementById("groupTypeWrapper").style.display = 'none'; document.getElementById("groupName").value = ''; document.getElementById("groupDescription").value = ''; document.getElementById("confirmGroupBtn").onclick = confirmCreatePhase;
        }
        function confirmCreatePhase() {
            const name = document.getElementById("groupName").value.trim(); if (!name) { alert("Phase name is required."); return; } const id = `phase_${Date.now()}`; const phase = new HierarchicalGroup(id, name, 'phase'); phase.description = document.getElementById("groupDescription").value.trim(); phases.set(id, phase); hideModals(); updateUI();
        }

        // --- CSV Import Functions ---
        function triggerImport() { document.getElementById('csvFileInput').click(); }
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const csvContent = e.target.result;
                try {
                    const parsedData = d3.csvParse(csvContent);
                    if (parsedData.length === 0) { throw new Error("CSV file is empty or invalid."); }
                    const headers = parsedData.columns;
                    showImportModal(parsedData, headers);
                } catch (error) {
                    alert(`Error parsing CSV file: ${error.message}`);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input to allow re-selection of the same file
        }

        function showImportModal(parsedData, headers) {
            const modal = document.getElementById("importModal");
            const selectIds = ["mapContextId", "mapDescription", "mapRelType", "mapRelTo"];
            
            const noMapOption = `<option value="">--- Do Not Map ---</option>`;
            const headerOptions = headers.map(h => `<option value="${h}">${h}</option>`).join('');

            selectIds.forEach(id => {
                const select = document.getElementById(id);
                select.innerHTML = noMapOption + headerOptions;
            });
            
            // Smart mapping
            const smartMap = {
                mapContextId: ['id', 'context', 'context_id', 'unit'],
                mapDescription: ['desc', 'description', 'notes'],
                mapRelType: ['rel_type', 'relationship', 'rel type', 'type'],
                mapRelTo: ['rel_to', 'related_to', 'related context', 'is_below', 'is_above']
            };
            for (const [selectId, possibleHeaders] of Object.entries(smartMap)) {
                const foundHeader = headers.find(h => possibleHeaders.includes(h.toLowerCase().replace(/ /g, '_')));
                if (foundHeader) { document.getElementById(selectId).value = foundHeader; }
            }
            
            document.getElementById("confirmImportBtn").onclick = () => confirmImport(parsedData);
            modal.style.display = "flex";
        }
        
        function confirmImport(parsedData) {
            const mapping = {
                contextId: document.getElementById('mapContextId').value,
                description: document.getElementById('mapDescription').value,
                relType: document.getElementById('mapRelType').value,
                relTo: document.getElementById('mapRelTo').value,
            };
            
            if (!mapping.contextId) { alert("'Context ID' must be mapped to a column."); return; }
            
            if (document.getElementById('importClearData').checked) {
                contexts = new Map(); relationships = []; groups = new Map();
                subGroups = new Map(); phases = new Map(); temporalConflicts = [];
            }

            let importedContexts = 0;
            let importedRels = 0;

            parsedData.forEach(row => {
                const id = row[mapping.contextId]?.trim();
                if (!id) return;

                if (!contexts.has(id)) {
                    contexts.set(id, new ArchaeologicalContext(id));
                    importedContexts++;
                }
                const context = contexts.get(id);

                if (mapping.description && row[mapping.description]) {
                    context.description = row[mapping.description].trim();
                }
                
                const relType = row[mapping.relType]?.trim();
                const relTo = row[mapping.relTo]?.trim();
                
                if (relType && relTo) {
                    if (!contexts.has(relTo)) {
                        contexts.set(relTo, new ArchaeologicalContext(relTo));
                        importedContexts++;
                    }
                    relationships.push({ from: id, to: relTo, type: relType.toLowerCase().replace(/ /g, '_') });
                    importedRels++;
                }
            });

            hideModals();
            updateUI();
            alert(`Import complete. Added ${importedContexts} new contexts and ${importedRels} relationships.`);
        }

        // --- Utility Functions ---
        function parseDateFromInputs(year, era) { if (isNaN(year) || year <= 0) return null; return era === 'BCE' ? -year : year; }
        function formatDateForDisplay(internalYear) { if (internalYear === null || internalYear === 0) return { year: '', era: 'CE' }; return internalYear < 0 ? { year: Math.abs(internalYear), era: 'BCE' } : { year: internalYear, era: 'CE' }; }
        function dateToString(internalYear) { if (internalYear === null || internalYear === 0) return ''; const { year, era } = formatDateForDisplay(internalYear); return `${year} ${era}`; }
        function suggestNextContextId() { if (contexts.size === 0) return "1001"; const numbers = Array.from(contexts.keys()).map(id => parseInt(id.match(/\d+$/)?.[0])).filter(n => !isNaN(n)); return numbers.length > 0 ? (Math.max(...numbers) + 1).toString() : (1000 + contexts.size + 1).toString(); }
        function hideModals() { document.querySelectorAll('.modal-backdrop').forEach(m => m.style.display = 'none'); }
        function removeRelationship(index) { relationships.splice(index, 1); updateUI(); }
        function resetZoom() { svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity); }
        function confirmClear() { if (window.confirm("Delete all data? This cannot be undone.")) { localStorage.removeItem('harrisMatrixData'); contexts = new Map();
        relationships = [];
        groups = new Map();
        subGroups = new Map();
        phases = new Map();
        nodePositions = {};
        temporalConflicts = [];updateUI(); } }
        function deleteContext(contextId) { if (window.confirm(`Are you sure you want to delete context "${contextId}" and all its relationships?`)) { const context = contexts.get(contextId); if (context.groupId) groups.get(context.groupId)?.contexts.delete(contextId); if (context.subGroupId) subGroups.get(context.subGroupId)?.contexts.delete(contextId); contexts.delete(contextId); relationships = relationships.filter(rel => rel.from !== contextId && rel.to !== contextId); temporalConflicts = temporalConflicts.filter(c => c.context1 !== contextId && c.context2 !== contextId); hideModals(); updateUI(); } }
        function highlightBy(filterFn, color) { g.selectAll('.context-node-group').each(function() { const node = d3.select(this); const rect = node.select('rect'); const isSelected = filterFn(contexts.get(node.datum())); rect.transition().duration(300).attr('stroke-width', isSelected ? '4px' : '2px').attr('stroke', isSelected ? color : (rect.classed('temporal-conflict') ? '#c82333' : (rect.classed('phased') ? '#1e7e34' : (rect.classed('grouped') ? '#e0a800' : 'var(--primary-accent-hover)')))); }); }
        function highlightPhase(id) { highlightBy(c => c.phaseId === id, '#4caf50'); }
        function highlightGroup(id) { highlightBy(c => c.groupId === id, '#ff9800'); }
        function highlightSubGroup(id) { highlightBy(c => c.subGroupId === id, '#9c27b0'); }
        function highlightContext(id) { highlightBy(c => c.id === id, 'gold'); }
        
        // --- Data Persistence ---
        function saveToStorage() {
            const data = {
                contexts: Array.from(contexts.entries()), relationships,
                groups: Array.from(groups.entries()).map(([id, group]) => [id, { ...group, contexts: Array.from(group.contexts), subGroups: Array.from(group.subGroups) }]),
                subGroups: Array.from(subGroups.entries()).map(([id, subGroup]) => [id, { ...subGroup, contexts: Array.from(subGroup.contexts) }]),
                phases: Array.from(phases.entries()),
            };
            localStorage.setItem('harrisMatrixData', JSON.stringify(data));
        }
        function loadFromStorage() {
            const rawData = localStorage.getItem('harrisMatrixData');
            if (!rawData) return;
            const data = JSON.parse(rawData);
            contexts = new Map(data.contexts.map(([id, obj]) => [id, Object.assign(new ArchaeologicalContext(id), obj)]));
            relationships = data.relationships || [];
            groups = new Map((data.groups || []).map(([id, obj]) => [id, Object.assign(new HierarchicalGroup(id), { ...obj, contexts: new Set(obj.contexts), subGroups: new Set(obj.subGroups) })]));
            subGroups = new Map((data.subGroups || []).map(([id, obj]) => [id, Object.assign(new HierarchicalGroup(id), { ...obj, contexts: new Set(obj.contexts) })]));
            phases = new Map((data.phases || []).map(([id, obj]) => [id, Object.assign(new HierarchicalGroup(id), obj)]));
        }
        
        // --- Export Functions ---
        function exportEnhancedData() {
            if (contexts.size === 0) { alert("No data to export."); return; }
            let csvContent = "data:text/csv;charset=utf-8,";
            const headers = ["Context_ID", "Context_Type", "Description", "Earliest_Date_Year", "Earliest_Date_Era", "Latest_Date_Year", "Latest_Date_Era", "Date_Type", "Phase_ID", "Phase_Name", "Group_ID", "Group_Name", "Sub-Group_ID", "Sub-Group_Name", "Relationship_Type", "Related_Context_ID", "Temporal_Conflict", "Is_Redundant"];
            csvContent += headers.join(",") + "\r\n";
            const redundantIndices = findRedundantRelationships();
            contexts.forEach(context => {
                const group = context.groupId ? groups.get(context.groupId) : null;
                const subGroup = context.subGroupId ? subGroups.get(context.subGroupId) : null;
                const phase = context.phaseId ? phases.get(context.phaseId) : null;
                const escapeCSV = (str) => `"${(str || '').toString().replace(/"/g, '""')}"`;
                const earliestDate = formatDateForDisplay(context.earliestDate);
                const latestDate = formatDateForDisplay(context.latestDate);
                const relsForContext = relationships.map((r, i) => ({...r, index: i})).filter(r => r.from === context.id);
                const hasConflict = temporalConflicts.some(c => c.context1 === context.id || c.context2 === context.id);
                const baseRow = [ escapeCSV(context.id), escapeCSV(context.type), escapeCSV(context.description), earliestDate.year, escapeCSV(earliestDate.era), latestDate.year, escapeCSV(latestDate.era), escapeCSV(context.dateType), escapeCSV(context.phaseId), escapeCSV(phase?.name), escapeCSV(context.groupId), escapeCSV(group?.name), escapeCSV(context.subGroupId), escapeCSV(subGroup?.name) ];
                if (relsForContext.length > 0) {
                    relsForContext.forEach(rel => { csvContent += [...baseRow, escapeCSV(rel.type), escapeCSV(rel.to), hasConflict, redundantIndices.has(rel.index)].join(",") + "\r\n"; });
                } else {
                    csvContent += [...baseRow, '', '', hasConflict, ''].join(",") + "\r\n";
                }
            });
            const link = document.createElement("a");
            link.setAttribute("href", encodeURI(csvContent));
            link.setAttribute("download", "enhanced_harris_matrix_data.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function getContentBBox() {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            let hasContent = false;
            g.selectAll(".context-node-group, .relationship-path, .group-boundary, .subgroup-boundary, .phase-boundary")
              .each(function() {
                  const bbox = this.getBBox();
                  if (bbox.width === 0 && bbox.height === 0) return; 
                  hasContent = true;
                  minX = Math.min(minX, bbox.x); minY = Math.min(minY, bbox.y);
                  maxX = Math.max(maxX, bbox.x + bbox.width); maxY = Math.max(maxY, bbox.y + bbox.height);
              });
            if (!hasContent) { return { x: 0, y: 0, width: 0, height: 0 }; }
            return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        }
        
        function triggerSVGFiledownload(svgString) {
            const blob = new Blob([svgString], { type: "image/svg+xml" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url; link.download = "harris_matrix.svg";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function exportViewAsSVG() {
            const bbox = getContentBBox();
            if (bbox.width === 0 || bbox.height === 0) { alert("There is nothing to export."); return; }
            const gridGroup = g.select(".grid-group");
            gridGroup.style("display", "none");
            const svgContent = g.node().innerHTML;
            gridGroup.style("display", null);
            let cssStyles = "";
            for (const sheet of document.styleSheets) {
                try {
                    for (const rule of sheet.cssRules) { cssStyles += rule.cssText + "\n"; }
                } catch (e) { console.warn("Could not read CSS rules; this can happen with external stylesheets.", e); }
            }
            const padding = 40;
            const standaloneSvgString = `<svg width="${bbox.width + padding * 2}" height="${bbox.height + padding * 2}" viewBox="${bbox.x - padding} ${bbox.y - padding} ${bbox.width + padding * 2} ${bbox.height + padding * 2}" xmlns="http://www.w3.org/2000/svg"><style>${cssStyles}</style>${svgContent}</svg>`;
            triggerSVGFiledownload(standaloneSvgString);
        }
    </script>
</body>
</html>
